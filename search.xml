<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6知识点</title>
    <url>/2020/03/10/ES6%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="hello-es6"><a href="#hello-es6" class="headerlink" title="hello-es6"></a>hello-es6</h1><hr>
<ul>
<li><p><a href="#hello-es6">hello-es6</a></p>
<ul>
<li><p><a href="#1es6%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84">1.ES6怎么来的</a></p>
</li>
<li><p><a href="#2es6%E5%85%BC%E5%AE%B9%E6%80%A7">2.ES6兼容性</a></p>
</li>
<li><p><a href="#3%E5%8F%98%E9%87%8F-let-%E5%92%8C-%E5%B8%B8%E9%87%8F-const">3.变量 let 和 常量 const</a></p>
</li>
<li><p><a href="#4%E5%87%BD%E6%95%B0-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">4.函数-箭头函数</a></p>
<a id="more"></a>
</li>
<li><p><a href="#5%E5%87%BD%E6%95%B0-%E5%8F%82%E6%95%B0">5.函数-参数</a></p>
</li>
<li><p><a href="#6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">6.解构赋值</a></p>
</li>
<li><p><a href="#7%E6%95%B0%E7%BB%84">7.数组</a></p>
</li>
<li><p><a href="#8%E5%AD%97%E7%AC%A6%E4%B8%B2">8.字符串</a></p>
</li>
<li><p><a href="#9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%9F%BA%E7%A1%80">9.面向对象-基础</a></p>
</li>
<li><p><a href="#10%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BA%94%E7%94%A8">10.面向对象应用</a></p>
</li>
<li><p><a href="#11json">11.json</a></p>
</li>
<li><p><a href="#12promise">12.Promise</a></p>
</li>
<li><p><a href="#13generator-%E8%AE%A4%E8%AF%86%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0">13.generator-认识生成器函数</a></p>
</li>
<li><p><a href="#14generator-yield%E6%98%AF%E5%95%A5">14.generator-yield是啥</a></p>
</li>
<li><p><a href="#15generator-%E5%AE%9E%E4%BE%8B">15.generator-实例</a></p>
</li>
<li><p><a href="#16es7-%E9%A2%84%E8%A7%88">16.ES7 预览</a></p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-ES6怎么来的"><a href="#1-ES6怎么来的" class="headerlink" title="1.ES6怎么来的"></a>1.ES6怎么来的</h2><ul>
<li><p>ECMAScript 和 JavaScript</p>
<ul>
<li>ECMA 是标准，JS 是实现</li>
<li>ECMAScript 简称 ECMA 或 ES</li>
</ul>
</li>
<li><p>历史版本</p>
<ul>
<li>1996, ES1.0 Netscape 将 JS 提交给 ECMA 组织，ES 正式出现</li>
<li>1999, ES3.0 被广泛支持</li>
<li>2011, ES5.1 成为 ISO 国际标准</li>
<li>2015, ES6.0 正式发布</li>
</ul>
</li>
</ul>
<h2 id="2-ES6兼容性"><a href="#2-ES6兼容性" class="headerlink" title="2.ES6兼容性"></a>2.ES6兼容性</h2><ul>
<li><p>ES6(ES2015) 支持的环境 IE10+, Chrome, FireFox, 移动端, NodeJS</p>
</li>
<li><p>解决不兼容办法，编译、转换</p>
<ul>
<li>在线转换</li>
<li>或者提前编译</li>
</ul>
</li>
<li><p><a href="https://www.babeljs.cn" target="_blank" rel="noopener">Babel 中文网</a></p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">Babel 入门教程 阮一峰</a></li>
<li>Babel 是一个 JavaScript 编译器</li>
<li>一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行</li>
<li>现在就用 ES6 编写程序，而不用担心现有环境是否支持</li>
</ul>
</li>
</ul>
<h2 id="3-变量-let-和-常量-const"><a href="#3-变量-let-和-常量-const" class="headerlink" title="3.变量 let 和 常量 const"></a>3.变量 let 和 常量 const</h2><ul>
<li><p>var 的问题</p>
<ul>
<li>可以重复声明，没有报错和警告</li>
<li>无法限制修改</li>
<li>没有块级作用域， <code>{ }</code></li>
</ul>
</li>
<li><p>let 和 const</p>
<ul>
<li>不能重复声明</li>
<li>都是块级作用域, <code>{ }</code> 块内声明的，块外无效</li>
<li>let 是变量，可以修改</li>
<li>const 是常量，不能修改</li>
</ul>
</li>
<li><p>块级作用域举例</p>
<ul>
<li>原来用 var 的方式，结果弹出的都是 3</li>
<li>或者将变量 封装到函数里，限制作用域，但比较麻烦</li>
<li>用 let 最简单，直接 var 改 let，解决作用域问题</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload= <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            /*</span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> aBtn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; aBtn.length; i++) &#123;</span></span><br><span class="line"><span class="actionscript">                aBtn[i].onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">                    alert(i)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;*/</span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> aBtn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; aBtn.length; i++) &#123;</span></span><br><span class="line"><span class="actionscript">                aBtn[i].onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">                    alert(i)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            /*</span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> aBtn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; aBtn.length; i++) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 封装到函数里，限制作用域</span></span></span><br><span class="line"><span class="actionscript">                (<span class="function"><span class="keyword">function</span> <span class="params">(i)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                    aBtn[i].onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">                        alert(i)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)(i)</span><br><span class="line">            &#125;*/</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-函数-箭头函数"><a href="#4-函数-箭头函数" class="headerlink" title="4.函数-箭头函数"></a>4.函数-箭头函数</h2><ul>
<li>箭头函数，就是函数的简写<ul>
<li>如果只有一个参数，<code>()</code> 可以省</li>
<li>如果只有一个<code>return</code>，<code>{}</code>可以省</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数，去掉 function， 加上 =&gt;</span></span><br><span class="line">() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> show1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'abc'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> show2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'abc'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show1() <span class="comment">// 调用函数</span></span><br><span class="line">show2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> show4 = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> show5 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>  <span class="comment">//简洁，类似python lambda 函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(show4(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">console</span>.log(show5(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<h2 id="5-函数-参数"><a href="#5-函数-参数" class="headerlink" title="5.函数-参数"></a>5.函数-参数</h2><ul>
<li>参数扩展／展开 <code>...args</code><ul>
<li>收集剩余的参数，必须当到最后一个参数位置</li>
<li>展开数组，简写，效果和直接把数组的内容写在这儿一样</li>
</ul>
</li>
<li>默认参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">a, b, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">    <span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(show(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr3 = [...arr1, ...arr2]</span><br><span class="line"><span class="built_in">console</span>.log(arr3)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show2</span>(<span class="params">a, b=<span class="number">5</span>, c=<span class="number">8</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line">show2(<span class="number">88</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-解构赋值"><a href="#6-解构赋值" class="headerlink" title="6.解构赋值"></a>6.解构赋值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;x, y, z&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [json, arr, num, str] = [&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">8</span>, <span class="string">'str'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(json, arr, num, str)</span><br></pre></td></tr></table></figure>

<ul>
<li>解构赋值<ul>
<li>左右两个边结构必须一样</li>
<li>右边必须是个东西</li>
<li>声明和赋值赋值不能分开，必须在一句话里</li>
</ul>
</li>
</ul>
<h2 id="7-数组"><a href="#7-数组" class="headerlink" title="7.数组"></a>7.数组</h2><ul>
<li>新增4个方法</li>
<li>map 映射  一个对一个</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> result = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> result2 = arr.map(<span class="function"><span class="params">item</span>=&gt;</span>item*<span class="number">2</span>) <span class="comment">// 简写</span></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="built_in">console</span>.log(result2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> score = [<span class="number">18</span>, <span class="number">86</span>, <span class="number">88</span>, <span class="number">24</span>]</span><br><span class="line"><span class="keyword">let</span> result3 = score.map(<span class="function"><span class="params">item</span> =&gt;</span> item &gt;= <span class="number">60</span> ? <span class="string">'及格'</span> : <span class="string">'不及格'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">[ <span class="number">24</span>, <span class="number">10</span>, <span class="number">16</span> ]</span><br><span class="line">[ <span class="number">24</span>, <span class="number">10</span>, <span class="number">16</span> ]</span><br><span class="line">[ <span class="string">'不及格'</span>, <span class="string">'及格'</span>, <span class="string">'及格'</span>, <span class="string">'不及格'</span> ]</span><br></pre></td></tr></table></figure>

<ul>
<li>reduce 汇总  一堆出来一个<ul>
<li>用于比如，算个总数，算个平均</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">tmp, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//tmp 上次结果，item当前数，index次数1开始</span></span><br><span class="line">    <span class="built_in">console</span>.log(tmp, item, index)</span><br><span class="line">    <span class="keyword">return</span> tmp + item</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">tmp, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index != arr.length - <span class="number">1</span>) &#123; <span class="comment">// 不是最后一次</span></span><br><span class="line">        <span class="keyword">return</span> tmp + item</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (tmp + item)/arr.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 平均值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>filter 过滤器 保留为true的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> (item % <span class="number">3</span> === <span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="keyword">var</span> result = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">3</span> === <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'苹果'</span>, <span class="attr">price</span>: <span class="number">10</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'西瓜'</span>, <span class="attr">price</span>: <span class="number">20</span> &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> result = arr.filter(<span class="function"><span class="params">json</span> =&gt;</span> json.price &gt;= <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<ul>
<li>forEach 循环迭代</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item))</span><br><span class="line"><span class="keyword">var</span> result = arr.forEach(<span class="function">(<span class="params">item, index</span>)=&gt;</span><span class="built_in">console</span>.log(item, index))</span><br></pre></td></tr></table></figure>

<h2 id="8-字符串"><a href="#8-字符串" class="headerlink" title="8.字符串"></a>8.字符串</h2><ul>
<li>多了两个新方法<ul>
<li><code>startsWith</code></li>
<li><code>endsWith</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://qq.com'</span></span><br><span class="line"><span class="built_in">console</span>.log(url.startsWith(<span class="string">'http'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(url.endsWith(<span class="string">'com'</span>))</span><br><span class="line"><span class="comment">// 都是 true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串模版<ul>
<li>使用反引号，<code>${变量}</code></li>
<li>可以折行</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">`asdf<span class="subst">$&#123;a&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(str1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title = <span class="string">'标题'</span></span><br><span class="line"><span class="keyword">let</span> content = <span class="string">'内容'</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;h1&gt;<span class="subst">$&#123;title&#125;</span>&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;<span class="subst">$&#123;content&#125;</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1&gt;标题&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;内容&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure>

<h2 id="9-面向对象-基础"><a href="#9-面向对象-基础" class="headerlink" title="9.面向对象-基础"></a>9.面向对象-基础</h2><ul>
<li>原来写法<ul>
<li>类和构造函数一样</li>
<li>属性和方法分开写的</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, pass</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.pass = pass</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.showPass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.pass)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u1 = <span class="keyword">new</span> User(<span class="string">'able'</span>, <span class="string">'1233'</span>)</span><br><span class="line">u1.showName()</span><br><span class="line">u1.showPass()</span><br><span class="line"><span class="comment">// 老版本继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">VipUser</span>(<span class="params">name, pass, level</span>) </span>&#123;</span><br><span class="line">    User.call(<span class="keyword">this</span>, name, pass)</span><br><span class="line">    <span class="keyword">this</span>.level = level</span><br><span class="line">&#125;</span><br><span class="line">VipUser.prototype = <span class="keyword">new</span> User()</span><br><span class="line">VipUser.prototype.constructor = VipUser</span><br><span class="line">VipUser.prototype.showLevel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.level)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> VipUser(<span class="string">'blue'</span>, <span class="string">'1234'</span>, <span class="number">3</span>)</span><br><span class="line">v1.showName()</span><br><span class="line">v1.showLevel()</span><br></pre></td></tr></table></figure>

<ul>
<li>新版面向对象<ul>
<li>有了 class 关键字、构造器</li>
<li>class 里面直接加方法</li>
<li>继承，super 超类==父类</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, pass) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.pass = pass</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    showName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    showPass() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.pass)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u1 = <span class="keyword">new</span> User(<span class="string">'able2'</span>, <span class="string">'111'</span>)</span><br><span class="line">u1.showName()</span><br><span class="line">u1.showPass()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新版本继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VipUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, pass, level) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name, pass)</span><br><span class="line">        <span class="keyword">this</span>.level = level</span><br><span class="line">    &#125;</span><br><span class="line">    showLevel()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.level)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v1 = <span class="keyword">new</span> VipUser(<span class="string">'blue'</span>, <span class="string">'123'</span>, <span class="number">3</span>)</span><br><span class="line">v1.showLevel()</span><br></pre></td></tr></table></figure>

<h2 id="10-面向对象应用"><a href="#10-面向对象应用" class="headerlink" title="10.面向对象应用"></a>10.面向对象应用</h2><ul>
<li><a href="https://www.reactjscn.com" target="_blank" rel="noopener">React</a><ul>
<li>用于构建用户界面的 JavaScript 库</li>
<li>组件化，一个组件就是一个 class</li>
<li>JSX == bable == browser.js</li>
</ul>
</li>
</ul>
<h2 id="11-json"><a href="#11-json" class="headerlink" title="11.json"></a>11.json</h2><ul>
<li><p>JSON 格式</p>
<ul>
<li>JavaScript Object Notation 的缩写，是一种用于数据交换的文本格式</li>
<li>JSON 是 JS对象 的严格子集</li>
<li>JSON 的标准写法</li>
<li>只能用双引号</li>
<li>所有的key都必须用双引号包起来</li>
</ul>
</li>
<li><p>JSON 对象</p>
<ul>
<li>JSON 对象是 JavaScript 的原生对象，用来处理 JSON 格式数据，有两个静态方法</li>
<li>JSON.parse(string) ：接受一个 <strong>JSON 字符串</strong>并将其转换成一个 JavaScript <strong>对象</strong>。</li>
<li>JSON.stringify(obj) ：接受一个 JavaScript <strong>对象</strong>并将其转换为一个 <strong>JSON 字符串</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;<span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hi,'</span> + <span class="built_in">JSON</span>.stringify(json)</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'http://www.xx.com/'</span> + <span class="built_in">encodeURIComponent</span>(<span class="built_in">JSON</span>.stringify(json))</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line"><span class="built_in">console</span>.log(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'&#123;"a": 12, "b": 4, "c": "abc"&#125;'</span></span><br><span class="line"><span class="keyword">var</span> json = <span class="built_in">JSON</span>.parse(str)</span><br><span class="line"><span class="built_in">console</span>.log(json)</span><br><span class="line">hi,&#123;<span class="string">"a"</span>:<span class="number">12</span>,<span class="string">"b"</span>:<span class="number">5</span>&#125;</span><br><span class="line">http:<span class="comment">//www.xx.com/%7B%22a%22%3A12%2C%22b%22%3A5%7D</span></span><br><span class="line">&#123; <span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="string">'abc'</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对象（object）</p>
<ul>
<li>是 JavaScript 语言的核心概念，也是最重要的数据类型</li>
<li>对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合</li>
<li>对象的所有键名都是字符串, 所以加不加引号都可以</li>
<li>如果键名是数值，会被自动转为字符串</li>
<li>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型</li>
<li>如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用</li>
<li>in 运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值</li>
<li>for…in循环用来遍历一个对象的全部属性</li>
</ul>
</li>
<li><p>对象 简写</p>
<ul>
<li>key-value 一样时可以简写</li>
<li>里面函数可以简写, 去掉</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>, b = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>:a, <span class="attr">b</span>:b&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(&#123;a, b&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(&#123;a, b, <span class="attr">c</span>:<span class="string">"c"</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(&#123; a, b, show()&#123; <span class="built_in">console</span>.log(<span class="string">'a'</span>) &#125;&#125;)</span><br><span class="line">&#123; <span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">5</span> &#125;</span><br><span class="line">&#123; <span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">5</span> &#125;</span><br><span class="line">&#123; <span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">5</span>, <span class="attr">c</span>: <span class="string">'c'</span> &#125;</span><br><span class="line">&#123; <span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">5</span>, <span class="attr">show</span>: [<span class="built_in">Function</span>: show] &#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-Promise"><a href="#12-Promise" class="headerlink" title="12.Promise"></a>12.Promise</h2><ul>
<li><p>异步和同步</p>
<ul>
<li>异步，操作之间没有关系，同时执行多个操作， 代码复杂</li>
<li>同步，同时只能做一件事，代码简单</li>
</ul>
</li>
<li><p>Promise 对象</p>
<ul>
<li>用同步的方式来书写异步代码</li>
<li>Promise 让异步操作写起来，像在写同步操作的流程，不必一层层地嵌套回调函数</li>
<li>改善了可读性，对于多层嵌套的回调函数很方便</li>
<li>充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口</li>
</ul>
</li>
<li><p>Promise 也是一个构造函数</p>
<ul>
<li>接受一个回调函数f1作为参数，f1里面是异步操作的代码</li>
<li>返回的p1就是一个 Promise 实例</li>
<li>所有异步任务都返回一个 Promise 实例</li>
<li>Promise 实例有一个then方法，用来指定下一步的回调函数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 异步代码...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(f1);</span><br><span class="line">p1.then(f2); <span class="comment">// f1的异步操作执行完成，就会执行f2。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Promise 使得异步流程可以写成同步流程</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line">step1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">  step2(value1, <span class="function"><span class="keyword">function</span>(<span class="params">value2</span>) </span>&#123;</span><br><span class="line">    step3(value2, <span class="function"><span class="keyword">function</span>(<span class="params">value3</span>) </span>&#123;</span><br><span class="line">      step4(value3, <span class="function"><span class="keyword">function</span>(<span class="params">value4</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 的写法</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Promise</span>(step1))</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(step4);</span><br></pre></td></tr></table></figure>

<ul>
<li>Promise.all(promiseArray)方法<ul>
<li>将多个Promise对象实例包装，生成并返回一个新的Promise实例</li>
<li>promise数组中所有的promise实例都变为resolve的时候，该方法才会返回</li>
<li>并将所有结果传递results数组中</li>
<li>promise数组中任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    p2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>),</span><br><span class="line">    p3 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results);  <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Promise.race([p1, p2, p3])<ul>
<li>Promse.race就是赛跑的意思</li>
<li>哪个结果获得的快，就返回那个结果</li>
<li>不管结果本身是成功状态还是失败状态</li>
</ul>
</li>
</ul>
<h2 id="13-generator-认识生成器函数"><a href="#13-generator-认识生成器函数" class="headerlink" title="13.generator-认识生成器函数"></a>13.generator-认识生成器函数</h2><ul>
<li>generator 生成器函数<ul>
<li>普通函数，一路到底</li>
<li>generator函数，中间可以停，到哪停呢，用 yield 配合，交出执行权</li>
<li>yield 有 放弃、退让、退位的意思</li>
<li>需要调用next()方法启动执行，需要遇到 yield 停, 踹一脚走一步</li>
<li>generator函数前面加一个 <code>*</code> 两边可以有空格，或靠近函数或<code>function</code></li>
<li>背后实际生成多个小函数，实现走走停停</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br><span class="line">&#125;</span><br><span class="line">show() <span class="comment">// 普通函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">show2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> genObj = show2()</span><br><span class="line">genObj.next() <span class="comment">// 1</span></span><br><span class="line">genObj.next() <span class="comment">// 2</span></span><br><span class="line">genObj.next() <span class="comment">// 最后了，没有结果</span></span><br></pre></td></tr></table></figure>

<h2 id="14-generator-yield是啥"><a href="#14-generator-yield是啥" class="headerlink" title="14.generator-yield是啥"></a>14.generator-yield是啥</h2><ul>
<li><p><code>yield</code></p>
<ul>
<li>既可传参，又可以返回</li>
<li>第一个<code>next()</code>传参无效，只用来启动</li>
</ul>
</li>
<li><p>如果函数前漏掉 <code>*</code></p>
<ul>
<li>就是普通函数</li>
<li>如果有<code>yield</code>会报错， <code>ReferenceError: yield is not defined</code></li>
<li>yield 只能在Generator函数内部使用</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// yield 传参</span></span><br><span class="line"><span class="keyword">var</span> gen = show()</span><br><span class="line">gen.next() <span class="comment">// 1</span></span><br><span class="line">gen.next() <span class="comment">// 2 和 undefined 因为没有传参，yield没有返回值</span></span><br><span class="line"><span class="keyword">var</span> gen = show()</span><br><span class="line">gen.next(<span class="number">10</span>) <span class="comment">// 1 第一次执行到yield，但没有执行赋值</span></span><br><span class="line">gen.next(<span class="number">20</span>) <span class="comment">// 2 和 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">show2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">10</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// yield 返回</span></span><br><span class="line"><span class="keyword">var</span> gen = show2()</span><br><span class="line"><span class="keyword">var</span> res1 = gen.next()</span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// &#123; value: 10, done: false &#125;</span></span><br><span class="line"><span class="keyword">var</span> res2 = gen.next()</span><br><span class="line"><span class="built_in">console</span>.log(res2)</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125; 最后的value需要return返回</span></span><br></pre></td></tr></table></figure>

<h2 id="15-generator-实例"><a href="#15-generator-实例" class="headerlink" title="15.generator-实例"></a>15.generator-实例</h2><ul>
<li>Promise 适合一次读一组</li>
<li>generator 适合逻辑性的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带逻辑-generator</span></span><br><span class="line">runner(<span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> userData = <span class="keyword">yield</span> $.ajax(&#123;<span class="attr">url</span>: <span class="string">'getUserData'</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userData.type == <span class="string">'VIP'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> items = <span class="keyword">yield</span> $.ajax(&#123;<span class="attr">url</span>: <span class="string">'getVIPItems'</span>&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> items = <span class="keyword">yield</span> $.ajax(&#123;<span class="attr">url</span>: <span class="string">'getItems'</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// yield 实例，用同步方式写异步</span></span><br><span class="line">server.use(<span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">yield</span> db.query(<span class="string">`select * from user_table`</span>)</span><br><span class="line">    <span class="keyword">this</span>.body = data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="16-ES7-预览"><a href="#16-ES7-预览" class="headerlink" title="16.ES7 预览"></a>16.ES7 预览</h2><ul>
<li>数组<ul>
<li><code>arr.includes()</code> 数组是否包含某个东西</li>
<li>数组的 arr.keys(), arr,entries()</li>
<li>for … in 遍历数组 下标 key</li>
<li>for … of 遍历数组 值 value, 不能用于json</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 循环的时下标 key</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 循环的是值 value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'&gt;'</span>+i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'&gt;'</span> + key + value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json = &#123; <span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">5</span>, <span class="attr">c</span>: <span class="number">7</span> &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> json) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串<ul>
<li>padStart()/padEnd() 指定宽度，不够就补空格或指定字符</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'='</span> + <span class="string">'abcd'</span>.padStart(<span class="number">6</span>, <span class="string">'0'</span>) + <span class="string">'='</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'='</span> + <span class="string">'abcd'</span>.padEnd(<span class="number">6</span>, <span class="string">'0'</span>) + <span class="string">'='</span>)</span><br><span class="line">=<span class="number">00</span>abcd=</span><br><span class="line">=abcd00=</span><br></pre></td></tr></table></figure>

<ul>
<li><p>容忍度</p>
<ul>
<li>[1, 2, 3,] 老版数组最后不能有逗号，新的可以有</li>
<li>函数参数最后多的逗号也可以</li>
</ul>
</li>
<li><p>async await</p>
<ul>
<li>和 generator yield 类似</li>
<li>generator 不可以写成箭头函数， async 可以</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Vue进阶面试题</title>
    <url>/2020/02/28/Vue%E8%BF%9B%E9%98%B6%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Vue-常考进阶知识点"><a href="#Vue-常考进阶知识点" class="headerlink" title="Vue 常考进阶知识点"></a>Vue 常考进阶知识点</h1><h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><p>Vue 内部使用了 <code>Object.defineProperty()</code> 来实现数据响应式，通过这个函数可以监听到 <code>set</code> 和 <code>get</code> 的事件。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var data &#x3D; &#123; name: &#39;yck&#39; &#125;</span><br><span class="line">observe(data)</span><br><span class="line">let name &#x3D; data.name &#x2F;&#x2F; -&gt; get value</span><br><span class="line">data.name &#x3D; &#39;yyy&#39; &#x2F;&#x2F; -&gt; change value</span><br><span class="line"></span><br><span class="line">function observe(obj) &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断类型</span><br><span class="line">  if (!obj || typeof obj !&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(obj).forEach(key &#x3D;&gt; &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function defineReactive(obj, key, val) &#123;</span><br><span class="line">  &#x2F;&#x2F; 递归子属性</span><br><span class="line">  observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    &#x2F;&#x2F; 可枚举</span><br><span class="line">    enumerable: true,</span><br><span class="line">    &#x2F;&#x2F; 可配置</span><br><span class="line">    configurable: true,</span><br><span class="line">    &#x2F;&#x2F; 自定义函数</span><br><span class="line">    get: function reactiveGetter() &#123;</span><br><span class="line">      console.log(&#39;get value&#39;)</span><br><span class="line">      return val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter(newVal) &#123;</span><br><span class="line">      console.log(&#39;change value&#39;)</span><br><span class="line">      val &#x3D; newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码简单的实现了如何监听数据的 <code>set</code> 和 <code>get</code> 的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，才能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>在解析如上模板代码时，遇到 <code></code> 就会进行依赖收集。</p>
<p>接下来我们先来实现一个 <code>Dep</code> 类，用于解耦属性的依赖收集和派发更新操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过 Dep 解耦属性的依赖和更新操作</span><br><span class="line">class Dep &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.subs &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 添加依赖</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 更新</span><br><span class="line">  notify() &#123;</span><br><span class="line">    this.subs.forEach(sub &#x3D;&gt; &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 全局属性，通过该属性配置 Watcher</span><br><span class="line">Dep.target &#x3D; null</span><br></pre></td></tr></table></figure>

<p>以上的代码实现很简单，当需要依赖收集的时候调用 <code>addSub</code>，当需要派发更新的时候调用 <code>notify</code>。</p>
<p>接下来我们先来简单的了解下 Vue 组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用 <code>Object.defineProperty()</code>，然后实例化 <code>Watcher</code>，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。</p>
<p>因为这一小节主要目的是学习响应式原理的细节，所以接下来的代码会简略的表达触发依赖收集时的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Watcher &#123;</span><br><span class="line">  constructor(obj, key, cb) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 Dep.target 指向自己</span><br><span class="line">    &#x2F;&#x2F; 然后触发属性的 getter 添加监听</span><br><span class="line">    &#x2F;&#x2F; 最后将 Dep.target 置空</span><br><span class="line">    Dep.target &#x3D; this</span><br><span class="line">    this.cb &#x3D; cb</span><br><span class="line">    this.obj &#x3D; obj</span><br><span class="line">    this.key &#x3D; key</span><br><span class="line">    this.value &#x3D; obj[key]</span><br><span class="line">    Dep.target &#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    &#x2F;&#x2F; 获得新值</span><br><span class="line">    this.value &#x3D; this.obj[this.key]</span><br><span class="line">    &#x2F;&#x2F; 调用 update 方法更新 Dom</span><br><span class="line">    this.cb(this.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是 <code>Watcher</code> 的简单实现，在执行构造函数的时候将 <code>Dep.target</code> 指向自身，从而使得收集到了对应的 <code>Watcher</code>，在派发更新的时候取出对应的 <code>Watcher</code> 然后执行 <code>update</code> 函数。</p>
<p>接下来，需要对 <code>defineReactive</code> 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function defineReactive(obj, key, val) &#123;</span><br><span class="line">  &#x2F;&#x2F; 递归子属性</span><br><span class="line">  observe(val)</span><br><span class="line">  let dp &#x3D; new Dep()</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function reactiveGetter() &#123;</span><br><span class="line">      console.log(&#39;get value&#39;)</span><br><span class="line">      &#x2F;&#x2F; 将 Watcher 添加到订阅</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      return val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter(newVal) &#123;</span><br><span class="line">      console.log(&#39;change value&#39;)</span><br><span class="line">      val &#x3D; newVal</span><br><span class="line">      &#x2F;&#x2F; 执行 watcher 的 update 方法</span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。</p>
<p>现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var data &#x3D; &#123; name: &#39;yck&#39; &#125;</span><br><span class="line">observe(data)</span><br><span class="line">function update(value) &#123;</span><br><span class="line">  document.querySelector(&#39;div&#39;).innerText &#x3D; value</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 模拟解析到 &#96;&#123;&#123;name&#125;&#125;&#96; 触发的操作</span><br><span class="line">new Watcher(data, &#39;name&#39;, update)</span><br><span class="line">&#x2F;&#x2F; update Dom innerText</span><br><span class="line">data.name &#x3D; &#39;yyy&#39;</span><br></pre></td></tr></table></figure>

<h3 id="Object-defineProperty-的缺陷"><a href="#Object-defineProperty-的缺陷" class="headerlink" title="Object.defineProperty 的缺陷"></a>Object.defineProperty 的缺陷</h3><p>以上已经分析完了 Vue 的响应式原理，接下来说一点 <code>Object.defineProperty</code> 中的缺陷。</p>
<p>如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为 <code>Object.defineProperty</code> 不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p>
<p>对于第一个问题，Vue 提供了一个 API 解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断是否为数组且下标是否有效</span><br><span class="line">  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用 splice 函数触发派发更新</span><br><span class="line">    &#x2F;&#x2F; 该函数已被重写</span><br><span class="line">    target.length &#x3D; Math.max(target.length, key)</span><br><span class="line">    target.splice(key, 1, val)</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 判断 key 是否已经存在</span><br><span class="line">  if (key in target &amp;&amp; !(key in Object.prototype)) &#123;</span><br><span class="line">    target[key] &#x3D; val</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  const ob &#x3D; (target: any).__ob__</span><br><span class="line">  &#x2F;&#x2F; 如果对象不是响应式对象，就赋值返回</span><br><span class="line">  if (!ob) &#123;</span><br><span class="line">    target[key] &#x3D; val</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 进行双向绑定</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  &#x2F;&#x2F; 手动派发更新</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  return val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于数组而言，Vue 内部重写了以下函数实现派发更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获得数组原型</span><br><span class="line">const arrayProto &#x3D; Array.prototype</span><br><span class="line">export const arrayMethods &#x3D; Object.create(arrayProto)</span><br><span class="line">&#x2F;&#x2F; 重写以下函数</span><br><span class="line">const methodsToPatch &#x3D; [</span><br><span class="line">  &#39;push&#39;,</span><br><span class="line">  &#39;pop&#39;,</span><br><span class="line">  &#39;shift&#39;,</span><br><span class="line">  &#39;unshift&#39;,</span><br><span class="line">  &#39;splice&#39;,</span><br><span class="line">  &#39;sort&#39;,</span><br><span class="line">  &#39;reverse&#39;</span><br><span class="line">]</span><br><span class="line">methodsToPatch.forEach(function (method) &#123;</span><br><span class="line">  &#x2F;&#x2F; 缓存原生函数</span><br><span class="line">  const original &#x3D; arrayProto[method]</span><br><span class="line">  &#x2F;&#x2F; 重写函数</span><br><span class="line">  def(arrayMethods, method, function mutator (...args) &#123;</span><br><span class="line">  &#x2F;&#x2F; 先调用原生函数获得结果</span><br><span class="line">    const result &#x3D; original.apply(this, args)</span><br><span class="line">    const ob &#x3D; this.__ob__</span><br><span class="line">    let inserted</span><br><span class="line">    &#x2F;&#x2F; 调用以下几个函数时，监听新数据</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      case &#39;push&#39;:</span><br><span class="line">      case &#39;unshift&#39;:</span><br><span class="line">        inserted &#x3D; args</span><br><span class="line">        break</span><br><span class="line">      case &#39;splice&#39;:</span><br><span class="line">        inserted &#x3D; args.slice(2)</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if (inserted) ob.observeArray(inserted)</span><br><span class="line">    &#x2F;&#x2F; 手动派发更新</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>想必大家在使用 Vue 开发的过程中，基本都是使用模板的方式。那么你有过「模板是怎么在浏览器中运行的」这种疑虑嘛？</p>
<p>首先直接把模板丢到浏览器中肯定是不能运行的，模板只是为了方便开发者进行开发。Vue 会通过编译器将模板通过几个阶段最终编译为 <code>render</code> 函数，然后通过执行 <code>render</code> 函数生成 Virtual DOM 最终映射为真实 DOM。</p>
<p>接下来我们就来学习这个编译的过程，了解这个过程中大概发生了什么事情。这个过程其中又分为三个阶段，分别为：</p>
<ol>
<li>将模板解析为 AST</li>
<li>优化 AST</li>
<li>将 AST 转换为 <code>render</code> 函数</li>
</ol>
<p>在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 类型</span><br><span class="line">    type: 1,</span><br><span class="line">    &#x2F;&#x2F; 标签</span><br><span class="line">    tag,</span><br><span class="line">    &#x2F;&#x2F; 属性列表</span><br><span class="line">    attrsList: attrs,</span><br><span class="line">    &#x2F;&#x2F; 属性映射</span><br><span class="line">    attrsMap: makeAttrsMap(attrs),</span><br><span class="line">    &#x2F;&#x2F; 父节点</span><br><span class="line">    parent,</span><br><span class="line">    &#x2F;&#x2F; 子节点</span><br><span class="line">    children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后会根据这个最基本的 AST 对象中的属性，进一步扩展 AST。</p>
<p>当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 HTML5 <a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FGuide%2FHTML%2FContent_categories">Content Model</a> 规范等等问题。</p>
<p>接下来就是优化 AST 的阶段。在当前版本下，Vue 进行的优化内容其实还是不多的。只是对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功能。在下一个大版本中，Vue 会在优化 AST 的阶段继续发力，实现更多的优化功能，尽可能的在编译阶段压榨更多的性能，比如说提取静态的属性等等优化行为。</p>
<p>最后一个阶段就是通过 AST 生成 <code>render</code> 函数了。其实这一阶段虽然分支有很多，但是最主要的目的就是遍历整个 AST，根据不同的条件生成不同的代码罢了。</p>
<h2 id="NextTick-原理分析"><a href="#NextTick-原理分析" class="headerlink" title="NextTick 原理分析"></a>NextTick 原理分析</h2><p><code>nextTick</code> 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。</p>
<p>在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。</p>
<p>对于实现 macrotasks ，会先判断是否能使用 <code>setImmediate</code> ，不能的话降级为 <code>MessageChannel</code> ，以上都不行的话就使用 <code>setTimeout</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (typeof setImmediate !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else if (</span><br><span class="line">  typeof MessageChannel !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp;</span><br><span class="line">  (isNative(MessageChannel) ||</span><br><span class="line">    &#x2F;&#x2F; PhantomJS</span><br><span class="line">    MessageChannel.toString() &#x3D;&#x3D;&#x3D; &#39;[object MessageChannelConstructor]&#39;)</span><br><span class="line">) &#123;</span><br><span class="line">  const channel &#x3D; new MessageChannel()</span><br><span class="line">  const port &#x3D; channel.port2</span><br><span class="line">  channel.port1.onmessage &#x3D; flushCallbacks</span><br><span class="line">  macroTimerFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    port.postMessage(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  macroTimerFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码很简单，就是判断能不能使用相应的 API。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue面试题</title>
    <url>/2020/02/28/Vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Vue-常考基础知识点"><a href="#Vue-常考基础知识点" class="headerlink" title="Vue 常考基础知识点"></a>Vue 常考基础知识点</h1><h2 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h2><p>在 <code>beforeCreate</code> 钩子函数调用的时候，是获取不到 <code>props</code> 或者 <code>data</code> 中的数据的，因为这些数据的初始化都在 <code>initState</code> 中。</p>
<a id="more"></a>

<p>然后会执行 <code>created</code> 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。</p>
<p>接下来会先执行 <code>beforeMount</code> 钩子函数，开始创建 VDOM，最后执行 <code>mounted</code> 钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。</p>
<p>接下来是数据更新时会调用的钩子函数 <code>beforeUpdate</code> 和 <code>updated</code>，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。</p>
<p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</p>
<p>最后就是销毁组件的钩子函数 <code>beforeDestroy</code> 和 <code>destroyed</code>。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 <code>destroyed</code> 钩子函数。</p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>组件通信一般分为以下几种情况：</p>
<ul>
<li>父子组件通信</li>
<li>兄弟组件通信</li>
<li>跨多层级组件通信</li>
<li>任意组件</li>
</ul>
<p>对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。</p>
<h3 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h3><p>父组件通过 <code>props</code> 传递数据给子组件，子组件通过 <code>emit</code> 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。</p>
<p>这种父子通信方式也就是典型的单向数据流，父组件通过 <code>props</code> 传递数据，子组件不能直接修改 <code>props</code>， 而是必须通过发送事件的方式告知父组件修改数据。</p>
<p>另外这两种方式还可以使用语法糖 <code>v-model</code> 来直接实现，因为 <code>v-model</code> 默认会解析成名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。</p>
<p>当然我们还可以通过访问 <code>$parent</code> 或者 <code>$children</code> 对象来访问组件实例中的方法和数据。</p>
<p>另外如果你使用 Vue 2.3 及以上版本的话还可以使用 <code>$listeners</code> 和 <code>.sync</code> 这两个属性。</p>
<p><code>$listeners</code> 属性会将父组件中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器传递给子组件，子组件可以通过访问 <code>$listeners</code> 来自定义监听器。</p>
<p><code>.sync</code> 属性是个语法糖，可以很简单的实现子组件与父组件通信</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--父组件中--&gt;</span><br><span class="line">&lt;input :value.sync&#x3D;&quot;value&quot; &#x2F;&gt;</span><br><span class="line">&lt;!--以上写法等同于--&gt;</span><br><span class="line">&lt;input :value&#x3D;&quot;value&quot; @update:value&#x3D;&quot;v &#x3D;&gt; value &#x3D; v&quot;&gt;&lt;&#x2F;comp&gt;</span><br><span class="line">&lt;!--子组件中--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  this.$emit(&#39;update:value&#39;, 1)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><p>对于这种情况可以通过查找父组件中的子组件实现，也就是 <code>this.$parent.$children</code>，在 <code>$children</code>中可以通过组件 <code>name</code> 查询到需要的组件实例，然后进行通信。</p>
<h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><p>对于这种情况可以使用 Vue 2.2 新增的 API <code>provide / inject</code>，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。</p>
<p>假设有父组件 A，然后有一个跨多层级的子组件 B</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件 A</span><br><span class="line">export default &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    data: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子组件 B</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: [&#39;data&#39;],</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    &#x2F;&#x2F; 无论跨几层都能获得父组件的 data 属性</span><br><span class="line">    console.log(this.data) &#x2F;&#x2F; &#x3D;&gt; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h3><p>这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</p>
<h2 id="extend-能做什么"><a href="#extend-能做什么" class="headerlink" title="extend 能做什么"></a>extend 能做什么</h2><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建组件构造器</span><br><span class="line">let Component &#x3D; Vue.extend(&#123;</span><br><span class="line">  template: &#39;&lt;div&gt;test&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 挂载到 #app 上</span><br><span class="line">new Component().$mount(&#39;#app&#39;)</span><br><span class="line">&#x2F;&#x2F; 除了上面的方式，还可以用来扩展已有的组件</span><br><span class="line">let SuperComponent &#x3D; Vue.extend(Component)</span><br><span class="line">new SuperComponent(&#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">new SuperComponent().$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="mixin-和-mixins-区别"><a href="#mixin-和-mixins-区别" class="headerlink" title="mixin 和 mixins 区别"></a>mixin 和 mixins 区别</h2><p><code>mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">        &#x2F;&#x2F; ...逻辑</span><br><span class="line">        &#x2F;&#x2F; 这种方式会影响到每个组件的 beforeCreate 钩子函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>虽然文档不建议我们在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</p>
<p><code>mixins</code> 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。</p>
<p>另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读 <a href="https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fmixins.html">文档</a>。</p>
<h2 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="headerlink" title="computed 和 watch 区别"></a>computed 和 watch 区别</h2><p><code>computed</code> 是计算属性，依赖其他属性计算值，并且 <code>computed</code> 的值有缓存，只有当计算值变化才会返回内容。</p>
<p><code>watch</code> 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p>
<p>所以一般来说需要依赖别的属性来动态获得值的时候可以使用 <code>computed</code>，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 <code>watch</code>。</p>
<p>另外 <code>computed</code> 和 <code>watch</code> 还都支持对象的写法，这种方式知道的人并不多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.$watch(&#39;obj&#39;, &#123;</span><br><span class="line">    &#x2F;&#x2F; 深度遍历</span><br><span class="line">    deep: true,</span><br><span class="line">    &#x2F;&#x2F; 立即触发</span><br><span class="line">    immediate: true,</span><br><span class="line">    &#x2F;&#x2F; 执行的函数</span><br><span class="line">    handler: function(val, oldVal) &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data: &#123; a: 1 &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    aPlus: &#123;</span><br><span class="line">      &#x2F;&#x2F; this.aPlus 时触发</span><br><span class="line">      get: function () &#123;</span><br><span class="line">        return this.a + 1</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; this.aPlus &#x3D; 1 时触发</span><br><span class="line">      set: function (v) &#123;</span><br><span class="line">        this.a &#x3D; v - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="keep-alive-组件有什么作用"><a href="#keep-alive-组件有什么作用" class="headerlink" title="keep-alive 组件有什么作用"></a>keep-alive 组件有什么作用</h2><p>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 <code>keep-alive</code> 组件包裹需要保存的组件。</p>
<p>对于 <code>keep-alive</code> 组件来说，它拥有两个独有的生命周期钩子函数，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</p>
<h2 id="v-show-与-v-if-区别"><a href="#v-show-与-v-if-区别" class="headerlink" title="v-show 与 v-if 区别"></a>v-show 与 v-if 区别</h2><p><code>v-show</code> 只是在 <code>display: none</code> 和 <code>display: block</code> 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说 <code>v-show</code> 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</p>
<p><code>v-if</code> 的话就得说到 Vue 底层的编译了。当属性初始为 <code>false</code> 时，组件就不会被渲染，直到条件为 <code>true</code>，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。</p>
<p>并且基于 <code>v-if</code> 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</p>
<h2 id="组件中-data-什么时候可以使用对象"><a href="#组件中-data-什么时候可以使用对象" class="headerlink" title="组件中 data 什么时候可以使用对象"></a>组件中 data 什么时候可以使用对象</h2><p>这道题目其实更多考的是 JS 功底。</p>
<p>组件复用时所有组件实例都会共享 <code>data</code>，如果 <code>data</code> 是对象的话，就会造成一个组件修改 <code>data</code> 以后会影响到其他所有组件，所以需要将 <code>data</code> 写成函数，每次用到就调用一次函数获得新的数据。</p>
<p>当我们使用 <code>new Vue()</code> 的方式的时候，无论我们将 <code>data</code> 设置为对象还是函数都是可以的，因为 <code>new Vue()</code> 的方式是生成一个根组件，该组件不会复用，也就不存在共享 <code>data</code> 的情况了。</p>
<h2 id="谈谈你对MVVM开发模式的理解"><a href="#谈谈你对MVVM开发模式的理解" class="headerlink" title="谈谈你对MVVM开发模式的理解"></a>谈谈你对MVVM开发模式的理解</h2><ul>
<li>MVVM分为Model、View、ViewModel三者<ul>
<li>Model：代表数据模型，数据和业务逻辑都是在Model层中定义</li>
<li>View：代表UI视图，负责对数据的展示</li>
<li>ViewModel：负责监听Model中数据的改变并控制视图的更新，处理用户交互操作</li>
</ul>
</li>
</ul>
<p>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p>
<p>这种模式实现了Model和View的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作dom。</p>
<h2 id="对于组件通信你了解多少，请描述一下你是怎么完成组件的通信的"><a href="#对于组件通信你了解多少，请描述一下你是怎么完成组件的通信的" class="headerlink" title="对于组件通信你了解多少，请描述一下你是怎么完成组件的通信的"></a>对于组件通信你了解多少，请描述一下你是怎么完成组件的通信的</h2><ul>
<li>父传子用 props传递</li>
<li>子传父用$emit传递 </li>
<li>非父子之间的传值  建立一个空实例进行传值，中央事件总线机制</li>
<li>祖孙之间的传值可以利用provide inject模式</li>
</ul>
<h5 id="VUEX可以处理上述的每一个情况"><a href="#VUEX可以处理上述的每一个情况" class="headerlink" title="VUEX可以处理上述的每一个情况"></a>VUEX可以处理上述的每一个情况</h5><h2 id="关于单页应用首屏加载速度慢，出现白屏时间过长问题你怎么处理"><a href="#关于单页应用首屏加载速度慢，出现白屏时间过长问题你怎么处理" class="headerlink" title="关于单页应用首屏加载速度慢，出现白屏时间过长问题你怎么处理"></a>关于单页应用首屏加载速度慢，出现白屏时间过长问题你怎么处理</h2><ul>
<li>将公用的JS库通过script标签在index.html进行外部引入，减少我们打包出来的js文件的大小，让浏览器并行下载资源文件，提高下载速度</li>
<li>在配置路由的时候进行路由的懒加载，在调用到改路由时再加载次路由相对应的js文件</li>
<li>加一个首屏loading图或骨架屏，提高用户的体验</li>
<li>尽可能使用CSS Sprites和字体图标库</li>
<li>图片的懒加载等</li>
</ul>
<h2 id="从输入网址到网页渲染完成经历了什么"><a href="#从输入网址到网页渲染完成经历了什么" class="headerlink" title="从输入网址到网页渲染完成经历了什么"></a>从输入网址到网页渲染完成经历了什么</h2><ol>
<li>输入网址按回车键或点击跳转</li>
<li>发送到DNS服务器进行DNS解析，获取到我们对应web服务器对应的ip地址</li>
<li>与Web服务器建立TCP连接</li>
<li>浏览器向web服务器发送http请求</li>
<li>Web服务器进行响应请求并返回指定的url数据（当然这里也可能是错误信息或者重定向到新的url地址等）</li>
<li>浏览器下载web服务器返回的数据及解析html源文件</li>
<li>根据文件生成DOM树和样式树合成我们的渲染树，解析js，最后渲染我们的页面然后显示出来</li>
</ol>
<h2 id="关于修改了数据，视图不更新的理解和处理方式"><a href="#关于修改了数据，视图不更新的理解和处理方式" class="headerlink" title="关于修改了数据，视图不更新的理解和处理方式"></a>关于修改了数据，视图不更新的理解和处理方式</h2><ol>
<li><p>Vue中给data中的对象属性添加一个新的属性时会发生什么</p>
<p>经过打印发现数据是已经改变了，但是由于在Vue实例创建时， 新添加的属性并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局api——&gt; <code>$set()</code></p>
<p>$set()使用方法：</p>
<p>$set(需要修改的对象，”对象的属性”,值)</p>
</li>
</ol>
<h2 id="在vue里面你如何做数据的监听"><a href="#在vue里面你如何做数据的监听" class="headerlink" title="在vue里面你如何做数据的监听"></a>在vue里面你如何做数据的监听</h2><ol>
<li><p>watch里面监听</p>
<ul>
<li><p>第一种写法</p>
<p>​        watch:{<br>​                obj(newval,oldval){<br>​                    console.log(newval,oldval)<br>​                },<br>​            }</p>
</li>
<li><p>第二种写法可设置deep为true对数据进行深层遍历监听</p>
<p>​        watch:{<br>​                obj:{<br>​                    handler(newval,oldval){<br>​                        console.log(222)<br>​                        console.log(newval,oldval)<br>​                    },<br>​                    deep:true<br>​                }<br>​            }</p>
</li>
</ul>
</li>
<li><p>computed 里面监听</p>
<ul>
<li>computed里面的依赖改变时，所计算的属性或作出事实的改变</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>详解JS的EventLoop</title>
    <url>/2020/02/27/%E8%AF%A6%E8%A7%A3JS%E7%9A%84EventLoop/</url>
    <content><![CDATA[<h2 id="执行栈与事件队列"><a href="#执行栈与事件队列" class="headerlink" title="执行栈与事件队列"></a><strong>执行栈与事件队列</strong></h2><p>当<strong>javascript</strong>代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。</p>
<a id="more"></a>

<p>我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p>
<p>当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。</p>
<p>下面这个图片非常直观的展示了这个过程，其中的global就是初次运行脚本时向执行栈中加入的代码：</p>
<p><img src="/images/v2-2f761eb83b50f53d741e6aa1f15a9db1_b.webp" alt="aa"></p>
<p>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p>
<p>以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？前文提过，js的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）。</p>
<p>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p>
<p>这里还有一张图来展示这个过程：</p>
<p><img src="/images/v2-da078fa3eadf3db4bf455904ae06f84b_720w.jpg" alt="aa"></p>
<p>图中的stack表示我们所说的执行栈，web apis则是代表一些异步事件，而callback queue即事件队列。</p>
<h2 id="macro-task与micro-task"><a href="#macro-task与micro-task" class="headerlink" title="macro task与micro task"></a><strong>macro task与micro task</strong></h2><p>以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p>
<p>以下事件属于宏任务：</p>
<ul>
<li><code>setInterval()</code></li>
<li><code>setTimeout()</code></li>
</ul>
<p>以下事件属于微任务</p>
<ul>
<li><code>new Promise()</code></li>
<li><code>new MutaionObserver()</code></li>
</ul>
<p>前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。</p>
<p>我们只需记住<strong>当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong>。</p>
<p>这样就能解释下面这段代码的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve,reject)&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">    resolve(3)</span><br><span class="line">&#125;).then(function(val)&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>浅拷贝与深拷贝</title>
    <url>/2020/02/26/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝是拷贝一层，深层次的对象级别的就拷贝引用</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:&#123;<span class="attr">d</span>:<span class="number">10</span>,<span class="attr">e</span>:<span class="number">20</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    obj1[key] = obj[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Object.assign(obj1,obj) 也是浅拷贝</span></span><br><span class="line">obj.a=<span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.a)<span class="comment">//10 不会发生改变</span></span><br><span class="line">obj.c.d=<span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.c.d)<span class="comment">//100 一样改变</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>深拷贝是拷贝多层，每一级别的数据都会拷贝出来</p>
<p>第一种：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:&#123;<span class="attr">d</span>:<span class="number">10</span>,<span class="attr">e</span>:<span class="number">20</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line">obj1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">obj.c.d=<span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.c.d)<span class="comment">//10 不会改变</span></span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>)&#123;</span><br><span class="line">                target[key] = deepClone(obj[key])</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                target[key] = obj[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1 = deepClone(obj)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>防抖与节流</title>
    <url>/2020/02/26/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。（取消前面的计时，触发最后一次，重新计时）</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            callback.apply(<span class="keyword">this</span>,args)</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onclick=debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">500</span>)</span><br></pre></td></tr></table></figure>



<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。（一段时间触发一次）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback,duration</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">        <span class="keyword">if</span>(now - lastTime &gt; duration)&#123;</span><br><span class="line">            callback.apply(<span class="keyword">this</span>,args)</span><br><span class="line">            lastTime = now <span class="comment">//最后要把上一次的时间 变成 现在的时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onclick=throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>冒泡排序、插入排序、快速排序</title>
    <url>/2020/02/25/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>​    让数组中的当前项和后一项进行比较，如果当前项比后一项大，则两项交换位置</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>,<span class="number">8</span>,<span class="number">24</span>,<span class="number">16</span>,<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 外层循环 i 控制比较的轮数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">// 里层循环 j 控制每一轮比较的轮数 因为不用跟自己比 所以-1 </span></span><br><span class="line">        <span class="comment">// i=0时 冒出一个最大值 i=1时 冒出两个最大值 。。。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;arr.length<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                [arr[j],arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>],arr[j]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>​    类似打牌，每次从别人手里抽取一张牌，然后放到自己手里，再从后往前排（也可以从前往后），找到位置最后插进去</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>,<span class="number">8</span>,<span class="number">24</span>,<span class="number">16</span>,<span class="number">1</span>]</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">       <span class="comment">//1.准备一个新数组，用来存储抓到手里的牌，开始先抓一张牌进来</span></span><br><span class="line">       <span class="keyword">let</span> result = []</span><br><span class="line">       result.push(arr[<span class="number">0</span>])</span><br><span class="line">       <span class="comment">//2.从第二项开始一次抓牌，一直到把别人手里的牌抓光</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">           <span class="comment">//A 是新抓的牌</span></span><br><span class="line">           <span class="keyword">let</span> A = arr[i]</span><br><span class="line">           <span class="comment">// 和result手里的牌依次比较（从后向前比）</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">let</span> j = result.length<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">               <span class="comment">// 每次要比较的手里牌</span></span><br><span class="line">               <span class="keyword">let</span> B = result[j]</span><br><span class="line">               <span class="comment">//如果当前新牌A比要比较的牌B大了，把A放到B的后面</span></span><br><span class="line">               <span class="keyword">if</span>(A&gt;B)&#123;</span><br><span class="line">                   result.splice(j+<span class="number">1</span>,<span class="number">0</span>,A)</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//已经比到第一项了,把新牌放到手中最前面</span></span><br><span class="line">               <span class="keyword">if</span>(j===<span class="number">0</span>)&#123;</span><br><span class="line">                   result.unshift(A)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>先把中间项拿出来，让拿出来的每一项和中间项比较，比中间相小的放到左边  比他大的放到右边 然后递归</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">1</span>,<span class="number">24</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//4.结束递归 当arr中小于等于1项，则不用管</span></span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.找到数组的中间项，在原有的数组中把它移除</span></span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> middleValue = arr.splice(middle,<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">//2.准备左右两个数组，循环盛夏数组的每一项，比当前项小的放到左边，打的放到右边</span></span><br><span class="line">    <span class="keyword">let</span> arrLeft=[],arrRight=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> item = arr[i]</span><br><span class="line">        item&lt;middleValue ? arrLeft.push(item) : arrRight.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.递归方式让左右两边的数组持续这样处理，一直到左右两边都排好序（最后让左边+中间+后边）</span></span><br><span class="line">    <span class="keyword">return</span> quick(arrLeft).concat(middleValue,quick(arrRight))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>关于数组扁平化处理</title>
    <url>/2020/02/25/%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="数组扁平化，去除其中重复部分的数据，得到一个升序且不重复的数组"><a href="#数组扁平化，去除其中重复部分的数据，得到一个升序且不重复的数组" class="headerlink" title="数组扁平化，去除其中重复部分的数据，得到一个升序且不重复的数组"></a>数组扁平化，去除其中重复部分的数据，得到一个升序且不重复的数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,[<span class="number">11</span>,<span class="number">12</span>,[<span class="number">12</span>,<span class="number">13</span>,[<span class="number">14</span>]]]],<span class="number">10</span>]</span><br><span class="line"><span class="comment">//PS: 如果数组里包含json，那么第二种方法会失效，因为对象.tostring() =&gt; [object,Object]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一 使用ES6中提供的Array.prototype.flat 处理</span></span><br><span class="line">arr = [...new <span class="built_in">Set</span>(arr.flat(<span class="number">4</span>))].sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法二 把数组直接变为字符串即可</span></span><br><span class="line">   arr = arr.toString().split(<span class="string">','</span>).map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> item = <span class="built_in">Number</span>(item)</span><br><span class="line">   &#125;).sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span> a - b)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//方法三 用JSON.stringify() 然后去除 []</span></span><br><span class="line">   arr = <span class="built_in">JSON</span>.stringify(arr).replace(<span class="regexp">/(\[|\])/g</span>,<span class="string">''</span>).split(<span class="string">','</span>).map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> item = <span class="built_in">Number</span>(item)</span><br><span class="line">   &#125;).sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span> a - b)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法四 基于数组的some方法进行判断检测</span></span><br><span class="line">   <span class="keyword">while</span>(arr.some(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">Array</span>.isArray(item)))&#123;</span><br><span class="line">       arr = [].concat(...arr)</span><br><span class="line">   &#125;</span><br><span class="line">   arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a - b)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方法五 自己写递归</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">let</span> result = [],_this = <span class="keyword">this</span></span><br><span class="line">       <span class="keyword">let</span> fn = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">               <span class="keyword">let</span> item = arr[i]</span><br><span class="line">               <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item))&#123;</span><br><span class="line">                   fn(item)</span><br><span class="line">                   <span class="keyword">continue</span></span><br><span class="line">               &#125;</span><br><span class="line">               result.push(item)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       fn(_this)</span><br><span class="line">       <span class="keyword">return</span> result</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">Array</span>.prototype.a = a</span><br><span class="line">   arr = arr.a().sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript面试题(2)</title>
    <url>/2020/02/24/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98(2)/</url>
    <content><![CDATA[<h2 id="输出下面代码运行结果"><a href="#输出下面代码运行结果" class="headerlink" title="输出下面代码运行结果"></a>输出下面代码运行结果</h2><h3 id="example-1"><a href="#example-1" class="headerlink" title="example   1"></a>example   1</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;&#125;,b=<span class="string">'123'</span>,c=<span class="number">123</span></span><br><span class="line">a[b]=<span class="string">'b'</span> a[c]=<span class="string">'c'</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]) <span class="comment">// c   a['123'] 跟 a[123] 一个样</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="example-2"><a href="#example-2" class="headerlink" title="example   2"></a>example   2</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;&#125;,b=<span class="built_in">Symbol</span>(<span class="string">'123'</span>),c=<span class="built_in">Symbol</span>(<span class="string">'123'</span>)</span><br><span class="line">a[b]=<span class="string">'b'</span> a[c]=<span class="string">'c'</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]) <span class="comment">// b   Symbol创建的值是唯一的 b != c</span></span><br></pre></td></tr></table></figure>

<h3 id="example-3"><a href="#example-3" class="headerlink" title="example   3"></a>example   3</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;&#125;,b=&#123;<span class="attr">key</span>:<span class="string">'123'</span>&#125;,c=&#123;<span class="attr">key</span>:<span class="string">'456'</span>&#125;</span><br><span class="line">a[b]=<span class="string">'b'</span> a[c]=<span class="string">'c'</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]) <span class="comment">// c  对象的属性名不能是对象(会默认转换为字符串)[10,20]=&gt;"10,20"</span></span><br><span class="line">				<span class="comment">// 最后 a=&#123;"[object Object]" : "c"&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="example-4"><a href="#example-4" class="headerlink" title="example   4"></a>example   4</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Foo.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把Foo当做类，在原型上设置实例私有的属性方法 =&gt; 实例.a()</span></span><br><span class="line">    <span class="keyword">this</span>.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把Foo当做普通对象设置公有的属性方法  =&gt; Foo.a()</span></span><br><span class="line">Foo.prototype.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">Foo.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">Foo.a() <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Foo() <span class="comment">//obj可以调取原型上的方法 当这个实例创建时console.log(4) 被console.log(1)代替了</span></span><br><span class="line">obj.a() <span class="comment">// 2  优先调取私有属性</span></span><br><span class="line">Foo.a() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="编写一条正则，来验证此规则：一个6-16位的字符串，必须同时包含有大小写字母和数字"><a href="#编写一条正则，来验证此规则：一个6-16位的字符串，必须同时包含有大小写字母和数字" class="headerlink" title="编写一条正则，来验证此规则：一个6~16位的字符串，必须同时包含有大小写字母和数字"></a>编写一条正则，来验证此规则：一个6~16位的字符串，必须同时包含有大小写字母和数字</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ?!负向预查  ?=正向预查</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?!^[a-zA-Z]+$)(?!^[A-Z0-9]+$)(?!^[a-z0-9]+$)(?!^[0-9]+$)^[a-zA-Z0-9]&#123;6,16&#125;$/</span></span><br><span class="line"><span class="comment">//不能全是小写 全是大写 全是数字 全是小写和大写。。。</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="英文字母汉字组成的字符串，用正则给英文单词前后加空格"><a href="#英文字母汉字组成的字符串，用正则给英文单词前后加空格" class="headerlink" title="英文字母汉字组成的字符串，用正则给英文单词前后加空格"></a>英文字母汉字组成的字符串，用正则给英文单词前后加空格</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"ya索rui雯,开da！"</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\b[a-z]+\b/ig</span> <span class="comment">//  \b 匹配必须出现在 \w 和 \W 字符之间的边界上</span></span><br><span class="line">str = str.replace(reg,(value)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">" "</span>+value+<span class="string">" "</span></span><br><span class="line">&#125;).trim() <span class="comment">//去除前后空格</span></span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">//"ya 索 rui 雯,开 da ！"</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="给定两个数组，写一个方法来计算它们的交集"><a href="#给定两个数组，写一个方法来计算它们的交集" class="headerlink" title="给定两个数组，写一个方法来计算它们的交集"></a>给定两个数组，写一个方法来计算它们的交集</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nums1.forEach(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums2.indexOf(item)</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        arr.push(item)</span><br><span class="line">        nums2.splice(n,<span class="number">1</span>)</span><br><span class="line">        nums1.splice(index,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript面试题(1)</title>
    <url>/2020/02/24/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98(1)/</url>
    <content><![CDATA[<h2 id="call-和-apply的区别是什么，哪个性能更好一些"><a href="#call-和-apply的区别是什么，哪个性能更好一些" class="headerlink" title="call 和 apply的区别是什么，哪个性能更好一些"></a>call 和 apply的区别是什么，哪个性能更好一些</h2><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><ol>
<li><p>都是Function原型上的方法，每个函数作为Function类的实例都能调用这方法</p>
<a id="more"></a>
</li>
<li><p>都是改变函数this的指向</p>
</li>
</ol>
<h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ol>
<li>传参不一样，<strong>call</strong>是一个个传，<strong>apply</strong>用数组传</li>
<li>当参数大于<strong>3</strong>个时，<strong>call</strong>性能更好一些</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>) </span><br><span class="line">fn.apply(obj,[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>])</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'亚索'</span>,</span><br><span class="line">    myFun:<span class="function"><span class="keyword">function</span>(<span class="params">X</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + X)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name:<span class="string">'锐雯'</span></span><br><span class="line">&#125;</span><br><span class="line">obj.myFun.call(db,<span class="string">'开大'</span>) <span class="comment">//锐雯开大</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="实现（5）-add（3）-minus（2），使其输出结果为：6"><a href="#实现（5）-add（3）-minus（2），使其输出结果为：6" class="headerlink" title="实现（5）.add（3）.minus（2），使其输出结果为：6"></a>实现（5）.add（3）.minus（2），使其输出结果为：6</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 每一个方法执行完，都要返回number这个类的实例，这样才可以继续调用number类中的方法(链式写法)</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span> + n</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">minus</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span> - n</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">Number</span>.prototype.add = add</span><br><span class="line">     <span class="built_in">Number</span>.prototype.minus = minus</span><br><span class="line"> &#125;)();</span><br><span class="line"> <span class="comment">//在JS中不可能存在变量或者其他单纯只有数字，所以要加()</span></span><br><span class="line"> <span class="built_in">console</span>.log((<span class="number">5</span>).add(<span class="number">3</span>).minus(<span class="number">2</span>)) <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用new生成实例，那么箭头函数可以吗？为什么？"><a href="#箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用new生成实例，那么箭头函数可以吗？为什么？" class="headerlink" title="箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用new生成实例，那么箭头函数可以吗？为什么？"></a>箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用new生成实例，那么箭头函数可以吗？为什么？</h2><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><ol>
<li>箭头函数语法上比普通函数更加简洁</li>
<li>箭头函数没有自己的<strong>this</strong>，它里面出现的<strong>this</strong>从继承函数所处上下文的<strong>this</strong></li>
<li>箭头函数没有<strong>arguments</strong>（类数组），只能基于<strong>…args</strong>获取参数集合（数组）</li>
<li>箭头函数不能new执行（因为：箭头函数没有this也没有<strong>prototype</strong>）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        name:<span class="string">'obj'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fn1.call(obj) <span class="comment">//obj</span></span><br><span class="line">    <span class="keyword">let</span> fn2 = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//this指向所属上下文</span></span><br><span class="line">    &#125;</span><br><span class="line">    fn2.call(obj)<span class="comment">//window call方法无效</span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">    <span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//this =&gt; body</span></span><br><span class="line">        arr.srot(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//this =&gt; window  只是把这个方法传给sort 回调函数的this一般都是window</span></span><br><span class="line">        &#125;)</span><br><span class="line">        arr.srot(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//this =&gt;body</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//手写forEach</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">arr,callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            callback.call(arr,[arr[i],i]) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    each([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>],<span class="function"><span class="keyword">function</span> (<span class="params">item,index</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//如果callback没有call 那么this还是会指向window</span></span><br><span class="line">            <span class="comment">//this =&gt; 当前数组</span></span><br><span class="line">    &#125;)</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">...arg</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//console.log(arguments) //Uncaught ReferenceError: arguments is not defined</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg) <span class="comment">//[10,20,30]</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="如何把一个字符串的大小写取反，例如’AbC’-变成-‘aBc’"><a href="#如何把一个字符串的大小写取反，例如’AbC’-变成-‘aBc’" class="headerlink" title="如何把一个字符串的大小写取反，例如’AbC’ 变成 ‘aBc’"></a>如何把一个字符串的大小写取反，例如’AbC’ 变成 ‘aBc’</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"亚索锐雯yasuoRUIWEN!*10~haHa"</span></span><br><span class="line">str = str.replace(<span class="regexp">/[a-zA-Z]/g</span>,(content)=&gt;&#123;</span><br><span class="line">    <span class="comment">//content:每一次正则匹配的结果 y,a,s,u,o,R,U,I,W,E,N,h,a,H,a</span></span><br><span class="line">    <span class="comment">//如果转换成大写还是跟自己相同，那本来就是大写，否则就是小写</span></span><br><span class="line">    <span class="keyword">return</span> content.toUpperCase === content ? content.toLowerCase : content.toUpperCase()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="实现一个字符串匹配方法，从字符串-S-中，查找是否存在字符串T，若存在返回所在位置，不存在返回-1！（手写）"><a href="#实现一个字符串匹配方法，从字符串-S-中，查找是否存在字符串T，若存在返回所在位置，不存在返回-1！（手写）" class="headerlink" title="实现一个字符串匹配方法，从字符串 S 中，查找是否存在字符串T，若存在返回所在位置，不存在返回-1！（手写）"></a>实现一个字符串匹配方法，从字符串 S 中，查找是否存在字符串T，若存在返回所在位置，不存在返回-1！（手写）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.循环原始字符串中的每一项，让每一下从当前位置向后截取(substr)T.length个字符，然后和T进行比较</span></span><br><span class="line"><span class="comment">//2.正则</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIndexOf</span>(<span class="params">T</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this =&gt; S</span></span><br><span class="line">    <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(T)</span><br><span class="line">    res = reg.exec(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> res === <span class="literal">null</span> ? <span class="number">-1</span> : res.index</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span>.prototype.myIndexOf = myIndexOf</span><br><span class="line"><span class="keyword">let</span> S = <span class="string">"yasuoruiwenwuzhanpeng"</span>,</span><br><span class="line">    T = <span class="string">"wu"</span></span><br><span class="line"><span class="built_in">console</span>.log(S.myIndexOf(T)); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把 var 改成 let let存在块级作用域，每一次循环都会在当前块级作用域中形成一个私有变量i，存储0~9</span></span><br><span class="line"><span class="comment">//当定时器执行的时候，所使用的i就是块级作用域中的i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包写法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其实就是让 i 变成私有化</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//本该匿名的函数 如果设置了函数名，在外面无法调用，但是在函数里面是可以使用的</span></span><br><span class="line"><span class="comment">//比如let fn = function a()&#123;&#125;    a() =&gt; a is not defined</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    b=<span class="number">20</span></span><br><span class="line">    <span class="built_in">console</span>.log(b)  <span class="comment">// b()&#123;&#125;  如果要输出b为20 要 var b = 20</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">//所以在外面没有调用到b()</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.&#123;&#125; == &#123;&#125; 两个对象的比较，比较的是堆内存的地址</span></span><br><span class="line"><span class="comment">//2.null == undefined 相等的 / null === undefined 不相等</span></span><br><span class="line"><span class="comment">//3.NaN == NaN 不相等 NaN和谁都不相等</span></span><br><span class="line"><span class="comment">//4.[12] == "12" 对象和字符串比较，是把对象toString()转换为字符串后再进行比较的</span></span><br><span class="line"><span class="comment">//5.剩余所有情况在进行的比较的时候，都是转换为数字(前提数据类型不一样)</span></span><br><span class="line"><span class="comment">// 对象转数字：先转换为字符串(toString())，然后再转换为数字</span></span><br><span class="line"><span class="comment">// 字符串转数字：只要出现一个非数字字符，结果就是NaN</span></span><br><span class="line"><span class="comment">// 布尔转数字: true-&gt;1 false-&gt;0</span></span><br><span class="line"><span class="comment">// null 转数字0</span></span><br><span class="line"><span class="comment">// undefined 转数字NaN</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    n:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">//设成私有方法</span></span><br><span class="line">    toString:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++<span class="keyword">this</span>.n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a == 1 a 会调用a.toString() </span></span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a ==<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种:</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>,<span class="string">'a'</span>,&#123; <span class="comment">//一调用window.a  就会调用get</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> ++n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
